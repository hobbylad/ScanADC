<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ScanADC: ScanADC Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ScanADC<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">Arduino library to scan analogue inputs with ADC measuring and averaging in background under interrupt control.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_scan_a_d_c-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ScanADC Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class to scan analogue inputs with ADC measuring and averaging in background under interrupt control.  
 <a href="class_scan_a_d_c.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_scan_a_d_c_8h_source.html">src/ScanADC.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_scan_a_d_c_1_1channel__config__t.html">channel_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to hold configuration for a single channel.  <a href="struct_scan_a_d_c_1_1channel__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3f1524f64040d2f841032e9c7e1adda1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a3f1524f64040d2f841032e9c7e1adda1">_mux0_t</a> { <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af9924ab9820692b7635c8cd1347a8240">MUX_ADC0</a> = 0
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85ab217c7a2f9803059c1446200f65677b6">MUX_ADC1</a> = 1
, <a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6ea740d5fbc6f3d4372e57b64031e71ebe4">MUX_ADC2</a> = 2
, <a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6ead0145f78e5813c6f87407aada95a101b">MUX_ADC3</a> = 3
, <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af5dd6deb531b1f19d098d247423a60ec">MUX_ADC4</a> = 4
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af36f98f268be110012e83f57ac326e92">MUX_ADC5</a> = 5
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a5b6e20d2bef84685367567574987320b">MUX_ADC6</a> = 6
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a306b7cca5e7b3d0b769e2f7faf088ddc">MUX_ADC7</a> = 7
, <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85aa0957c67d95c54942133171a6385e9d2">MUX_ADC8</a> = 8
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a7620e7e5d36370bb89d8069684851f14">MUX_1V1</a> = 14
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af80686d0b71fb10d99b72901b63eba4e">MUX_0V0</a> = 15
<br />
 }</td></tr>
<tr class="memdesc:a3f1524f64040d2f841032e9c7e1adda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATmega328P/ATmega168 Hardware analogue input MUX value.  <a href="class_scan_a_d_c.html#a3f1524f64040d2f841032e9c7e1adda1">More...</a><br /></td></tr>
<tr class="separator:a3f1524f64040d2f841032e9c7e1adda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9313bcb77c86750f8ec1ed1a9f0c6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6e">_mux1_t</a> { <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af9924ab9820692b7635c8cd1347a8240">MUX_ADC0</a> = 0
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85ab217c7a2f9803059c1446200f65677b6">MUX_ADC1</a> = 1
, <a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6ea740d5fbc6f3d4372e57b64031e71ebe4">MUX_ADC2</a> = 2
, <a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6ead0145f78e5813c6f87407aada95a101b">MUX_ADC3</a> = 3
, <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af5dd6deb531b1f19d098d247423a60ec">MUX_ADC4</a> = 4
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af36f98f268be110012e83f57ac326e92">MUX_ADC5</a> = 5
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a5b6e20d2bef84685367567574987320b">MUX_ADC6</a> = 6
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a306b7cca5e7b3d0b769e2f7faf088ddc">MUX_ADC7</a> = 7
, <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a7620e7e5d36370bb89d8069684851f14">MUX_1V1</a> = 14
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af80686d0b71fb10d99b72901b63eba4e">MUX_0V0</a> = 15
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85aa61638b19324c013c781766ef5d83c38">MUX_ADC9</a> = 33
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85ade2ab1ee248745ce36122d909b703c86">MUX_ADC10</a> = 34
, <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a76684e1743f05c58c207c6b1ed585a66">MUX_ADC11</a> = 35
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a7ad182c23da9d8017848125333866bc7">MUX_ADC12</a> = 36
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a9a3fd0b936eacdfc74b3b307728a2c48">MUX_ADC13</a> = 37
, <a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6ea87fd99c685ac02b18cd1f6da87cba443">MUX_ADC14</a> = 38
, <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6ea9ff6f6709ca07893ce2b824e0122b9cd">MUX_ADC15</a> = 39
<br />
 }</td></tr>
<tr class="memdesc:a5f9313bcb77c86750f8ec1ed1a9f0c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATmega1280/ATmega2560 Hardware analogue input MUX value.  <a href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6e">More...</a><br /></td></tr>
<tr class="separator:a5f9313bcb77c86750f8ec1ed1a9f0c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f390b2dceb4266b842ea7fea619bb85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85">_mux2_t</a> { <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af9924ab9820692b7635c8cd1347a8240">MUX_ADC0</a> = 0
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85ab217c7a2f9803059c1446200f65677b6">MUX_ADC1</a> = 1
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af5dd6deb531b1f19d098d247423a60ec">MUX_ADC4</a> = 4
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af36f98f268be110012e83f57ac326e92">MUX_ADC5</a> = 5
, <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a5b6e20d2bef84685367567574987320b">MUX_ADC6</a> = 6
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a306b7cca5e7b3d0b769e2f7faf088ddc">MUX_ADC7</a> = 7
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a7620e7e5d36370bb89d8069684851f14">MUX_1V1</a> = 14
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85af80686d0b71fb10d99b72901b63eba4e">MUX_0V0</a> = 15
, <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85aa0957c67d95c54942133171a6385e9d2">MUX_ADC8</a> = 8
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85aa61638b19324c013c781766ef5d83c38">MUX_ADC9</a> = 33
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85ade2ab1ee248745ce36122d909b703c86">MUX_ADC10</a> = 34
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a76684e1743f05c58c207c6b1ed585a66">MUX_ADC11</a> = 35
, <br />
&#160;&#160;<a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a7ad182c23da9d8017848125333866bc7">MUX_ADC12</a> = 36
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85a9a3fd0b936eacdfc74b3b307728a2c48">MUX_ADC13</a> = 37
, <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85afe678f683c300c4e727d667d021ccf1d">MUX_TEMP</a> = 39
<br />
 }</td></tr>
<tr class="memdesc:a2f390b2dceb4266b842ea7fea619bb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATmega32U4/ATmega16U4 Hardware analogue input MUX value.  <a href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85">More...</a><br /></td></tr>
<tr class="separator:a2f390b2dceb4266b842ea7fea619bb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb94e2a79440d98bd1a53a2b910ae51b"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="class_scan_a_d_c.html#a3f1524f64040d2f841032e9c7e1adda1">ScanADC::_mux0_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#afb94e2a79440d98bd1a53a2b910ae51b">mux_t</a></td></tr>
<tr class="memdesc:afb94e2a79440d98bd1a53a2b910ae51b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATmega328P/ATmega168 Hardware analogue input MUX value.  <a href="class_scan_a_d_c.html#afb94e2a79440d98bd1a53a2b910ae51b">More...</a><br /></td></tr>
<tr class="separator:afb94e2a79440d98bd1a53a2b910ae51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11f4c9a35d286c01147e50fafaed495"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6e">ScanADC::_mux1_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#ac11f4c9a35d286c01147e50fafaed495">mux_t</a></td></tr>
<tr class="memdesc:ac11f4c9a35d286c01147e50fafaed495"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATmega1280/ATmega2560 Hardware analogue input MUX value.  <a href="class_scan_a_d_c.html#ac11f4c9a35d286c01147e50fafaed495">More...</a><br /></td></tr>
<tr class="separator:ac11f4c9a35d286c01147e50fafaed495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef2aaabbf1668dc30c246124ee16212"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85">ScanADC::_mux2_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a5ef2aaabbf1668dc30c246124ee16212">mux_t</a></td></tr>
<tr class="memdesc:a5ef2aaabbf1668dc30c246124ee16212"><td class="mdescLeft">&#160;</td><td class="mdescRight">ATmega32U4/ATmega16U4 Hardware analogue input MUX value.  <a href="class_scan_a_d_c.html#a5ef2aaabbf1668dc30c246124ee16212">More...</a><br /></td></tr>
<tr class="separator:a5ef2aaabbf1668dc30c246124ee16212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42496a3bdb8d9fdbc8e859da1294e5e5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a42496a3bdb8d9fdbc8e859da1294e5e5">channel_callback_t</a>) (uint8_t channel, uint16_t sample)</td></tr>
<tr class="memdesc:a42496a3bdb8d9fdbc8e859da1294e5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the channel measured callback.  <a href="class_scan_a_d_c.html#a42496a3bdb8d9fdbc8e859da1294e5e5">More...</a><br /></td></tr>
<tr class="separator:a42496a3bdb8d9fdbc8e859da1294e5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d2f660be94c65031f4f713f3283803"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a55d2f660be94c65031f4f713f3283803">channel_scan_callback_t</a>) (const uint16_t *samples)</td></tr>
<tr class="memdesc:a55d2f660be94c65031f4f713f3283803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of the channel scan measured callback.  <a href="class_scan_a_d_c.html#a55d2f660be94c65031f4f713f3283803">More...</a><br /></td></tr>
<tr class="separator:a55d2f660be94c65031f4f713f3283803"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a32a830c35b1e665023fd9145e43c12b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a32a830c35b1e665023fd9145e43c12b6">begin</a> (const <a class="el" href="struct_scan_a_d_c_1_1channel__config__t.html">channel_config_t</a> *channel_config, uint8_t channel_count)</td></tr>
<tr class="memdesc:a32a830c35b1e665023fd9145e43c12b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts scanning user defined analogue input channnels with the ADC under interrupt control.  <a href="class_scan_a_d_c.html#a32a830c35b1e665023fd9145e43c12b6">More...</a><br /></td></tr>
<tr class="separator:a32a830c35b1e665023fd9145e43c12b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b25eaea32c0626af37713c9160edd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a84b25eaea32c0626af37713c9160edd3">end</a> ()</td></tr>
<tr class="memdesc:a84b25eaea32c0626af37713c9160edd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops scanning disabling interrupt control.  <a href="class_scan_a_d_c.html#a84b25eaea32c0626af37713c9160edd3">More...</a><br /></td></tr>
<tr class="separator:a84b25eaea32c0626af37713c9160edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf871108bd5f9f119d4204eba59ea5b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#aaf871108bd5f9f119d4204eba59ea5b3">attach_channel_callback</a> (<a class="el" href="class_scan_a_d_c.html#a42496a3bdb8d9fdbc8e859da1294e5e5">channel_callback_t</a> cb=NULL)</td></tr>
<tr class="memdesc:aaf871108bd5f9f119d4204eba59ea5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures callback function to be called after each analogue channel is scanned.  <a href="class_scan_a_d_c.html#aaf871108bd5f9f119d4204eba59ea5b3">More...</a><br /></td></tr>
<tr class="separator:aaf871108bd5f9f119d4204eba59ea5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b84626f2f8d6dc7a9c290e630bfe3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a11b84626f2f8d6dc7a9c290e630bfe3d">attach_scan_callback</a> (<a class="el" href="class_scan_a_d_c.html#a55d2f660be94c65031f4f713f3283803">channel_scan_callback_t</a> cb=NULL)</td></tr>
<tr class="memdesc:a11b84626f2f8d6dc7a9c290e630bfe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures callback function to be called after all analogue channels are scanned.  <a href="class_scan_a_d_c.html#a11b84626f2f8d6dc7a9c290e630bfe3d">More...</a><br /></td></tr>
<tr class="separator:a11b84626f2f8d6dc7a9c290e630bfe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c313a5cc6692c6761150ba2aa7b72e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a31c313a5cc6692c6761150ba2aa7b72e">wait_channel</a> (uint8_t channel) const</td></tr>
<tr class="memdesc:a31c313a5cc6692c6761150ba2aa7b72e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a specified user configured channel has been measured.  <a href="class_scan_a_d_c.html#a31c313a5cc6692c6761150ba2aa7b72e">More...</a><br /></td></tr>
<tr class="separator:a31c313a5cc6692c6761150ba2aa7b72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa742f25553a586182136cbb4a2387faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#aa742f25553a586182136cbb4a2387faf">wait_scan</a> () const</td></tr>
<tr class="memdesc:aa742f25553a586182136cbb4a2387faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until all the user configured channels have been measured.  <a href="class_scan_a_d_c.html#aa742f25553a586182136cbb4a2387faf">More...</a><br /></td></tr>
<tr class="separator:aa742f25553a586182136cbb4a2387faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c8517ad8aca9dcffd5e2b0e34f8076"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a68c8517ad8aca9dcffd5e2b0e34f8076">get_sn</a> (uint8_t channel) const</td></tr>
<tr class="memdesc:a68c8517ad8aca9dcffd5e2b0e34f8076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sample sequence number for a channel.  <a href="class_scan_a_d_c.html#a68c8517ad8aca9dcffd5e2b0e34f8076">More...</a><br /></td></tr>
<tr class="separator:a68c8517ad8aca9dcffd5e2b0e34f8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11e9b305b91547986150c1fbf5a08fa"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#ae11e9b305b91547986150c1fbf5a08fa">get_sample</a> (uint8_t channel) const</td></tr>
<tr class="memdesc:ae11e9b305b91547986150c1fbf5a08fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads sample for a user configure channel.  <a href="class_scan_a_d_c.html#ae11e9b305b91547986150c1fbf5a08fa">More...</a><br /></td></tr>
<tr class="separator:ae11e9b305b91547986150c1fbf5a08fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_scan_a_d_c.html">ScanADC</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30">getInstance</a> ()</td></tr>
<tr class="memdesc:a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the single object of <a class="el" href="class_scan_a_d_c.html" title="Class to scan analogue inputs with ADC measuring and averaging in background under interrupt control.">ScanADC</a>.  <a href="class_scan_a_d_c.html#a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30">More...</a><br /></td></tr>
<tr class="separator:a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0d87c3127939beead634c98f160e7b38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scan_a_d_c.html#a0d87c3127939beead634c98f160e7b38">__vector_29</a> ()</td></tr>
<tr class="memdesc:a0d87c3127939beead634c98f160e7b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADC Interrupt Service Routine (ISR) declared as friend to allow access to member variables.  <a href="class_scan_a_d_c.html#a0d87c3127939beead634c98f160e7b38">More...</a><br /></td></tr>
<tr class="separator:a0d87c3127939beead634c98f160e7b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Class to scan analogue inputs with ADC measuring and averaging in background under interrupt control. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a42496a3bdb8d9fdbc8e859da1294e5e5" name="a42496a3bdb8d9fdbc8e859da1294e5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42496a3bdb8d9fdbc8e859da1294e5e5">&#9670;&nbsp;</a></span>channel_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ScanADC::channel_callback_t) (uint8_t channel, uint16_t sample)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of the channel measured callback. </p>
<p >The channel callback is called after a channel has been measured an will supply the <em>channel</em> and the measured <em>sample</em> as parameters.</p>
<p >Note that the callback is called from the ADC Interrupt Service Routine (ISR) and should be as short as possible. An example use is to push the sample into a queue for processing by the main thread. </p>

</div>
</div>
<a id="a55d2f660be94c65031f4f713f3283803" name="a55d2f660be94c65031f4f713f3283803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d2f660be94c65031f4f713f3283803">&#9670;&nbsp;</a></span>channel_scan_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ScanADC::channel_scan_callback_t) (const uint16_t *samples)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of the channel scan measured callback. </p>
<p >The channel scan callback is called after all the channels in the configuration have been measured and will supply a pointer to the channel samples #samples.</p>
<p >Note that the callback is called from the ADC Interrupt Service Routine (ISR) and should be as short as possible. An example use is to push the samples into a queue for processing by the main thread. </p>

</div>
</div>
<a id="afb94e2a79440d98bd1a53a2b910ae51b" name="afb94e2a79440d98bd1a53a2b910ae51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb94e2a79440d98bd1a53a2b910ae51b">&#9670;&nbsp;</a></span>mux_t <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="class_scan_a_d_c.html#a3f1524f64040d2f841032e9c7e1adda1">ScanADC::_mux0_t</a> <a class="el" href="class_scan_a_d_c.html#afb94e2a79440d98bd1a53a2b910ae51b">ScanADC::mux_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATmega328P/ATmega168 Hardware analogue input MUX value. </p>
<p >Only available if <b>AVR_ATmega328P</b> or <b>AVR_ATmega168</b> are defined by Arduino environment. </p>

</div>
</div>
<a id="ac11f4c9a35d286c01147e50fafaed495" name="ac11f4c9a35d286c01147e50fafaed495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11f4c9a35d286c01147e50fafaed495">&#9670;&nbsp;</a></span>mux_t <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6e">ScanADC::_mux1_t</a> <a class="el" href="class_scan_a_d_c.html#afb94e2a79440d98bd1a53a2b910ae51b">ScanADC::mux_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATmega1280/ATmega2560 Hardware analogue input MUX value. </p>
<p >Only available if <b>AVR_ATmega1280</b> or <b>AVR_ATmega2560</b> are defined by Arduino environment. </p>

</div>
</div>
<a id="a5ef2aaabbf1668dc30c246124ee16212" name="a5ef2aaabbf1668dc30c246124ee16212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef2aaabbf1668dc30c246124ee16212">&#9670;&nbsp;</a></span>mux_t <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85">ScanADC::_mux2_t</a> <a class="el" href="class_scan_a_d_c.html#afb94e2a79440d98bd1a53a2b910ae51b">ScanADC::mux_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATmega32U4/ATmega16U4 Hardware analogue input MUX value. </p>
<p >Only available if <b>AVR_ATmega32U4</b> or <b>AVR_ATmega16U4</b> are defined by Arduino environment. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3f1524f64040d2f841032e9c7e1adda1" name="a3f1524f64040d2f841032e9c7e1adda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1524f64040d2f841032e9c7e1adda1">&#9670;&nbsp;</a></span>_mux0_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_scan_a_d_c.html#a3f1524f64040d2f841032e9c7e1adda1">ScanADC::_mux0_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATmega328P/ATmega168 Hardware analogue input MUX value. </p>
<p >Only available if <b>AVR_ATmega328P</b> or <b>AVR_ATmega168</b> are defined by Arduino environment. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af9924ab9820692b7635c8cd1347a8240" name="a2f390b2dceb4266b842ea7fea619bb85af9924ab9820692b7635c8cd1347a8240"></a>MUX_ADC0&#160;</td><td class="fielddoc"><p >ADC0 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85ab217c7a2f9803059c1446200f65677b6" name="a2f390b2dceb4266b842ea7fea619bb85ab217c7a2f9803059c1446200f65677b6"></a>MUX_ADC1&#160;</td><td class="fielddoc"><p >ADC1 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f9313bcb77c86750f8ec1ed1a9f0c6ea740d5fbc6f3d4372e57b64031e71ebe4" name="a5f9313bcb77c86750f8ec1ed1a9f0c6ea740d5fbc6f3d4372e57b64031e71ebe4"></a>MUX_ADC2&#160;</td><td class="fielddoc"><p >ADC2 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f9313bcb77c86750f8ec1ed1a9f0c6ead0145f78e5813c6f87407aada95a101b" name="a5f9313bcb77c86750f8ec1ed1a9f0c6ead0145f78e5813c6f87407aada95a101b"></a>MUX_ADC3&#160;</td><td class="fielddoc"><p >ADC3 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af5dd6deb531b1f19d098d247423a60ec" name="a2f390b2dceb4266b842ea7fea619bb85af5dd6deb531b1f19d098d247423a60ec"></a>MUX_ADC4&#160;</td><td class="fielddoc"><p >ADC4 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af36f98f268be110012e83f57ac326e92" name="a2f390b2dceb4266b842ea7fea619bb85af36f98f268be110012e83f57ac326e92"></a>MUX_ADC5&#160;</td><td class="fielddoc"><p >ADC5 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a5b6e20d2bef84685367567574987320b" name="a2f390b2dceb4266b842ea7fea619bb85a5b6e20d2bef84685367567574987320b"></a>MUX_ADC6&#160;</td><td class="fielddoc"><p >ADC6 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a306b7cca5e7b3d0b769e2f7faf088ddc" name="a2f390b2dceb4266b842ea7fea619bb85a306b7cca5e7b3d0b769e2f7faf088ddc"></a>MUX_ADC7&#160;</td><td class="fielddoc"><p >ADC7 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85aa0957c67d95c54942133171a6385e9d2" name="a2f390b2dceb4266b842ea7fea619bb85aa0957c67d95c54942133171a6385e9d2"></a>MUX_ADC8&#160;</td><td class="fielddoc"><p >ADC8 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a7620e7e5d36370bb89d8069684851f14" name="a2f390b2dceb4266b842ea7fea619bb85a7620e7e5d36370bb89d8069684851f14"></a>MUX_1V1&#160;</td><td class="fielddoc"><p >1.1V internal bandgap. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af80686d0b71fb10d99b72901b63eba4e" name="a2f390b2dceb4266b842ea7fea619bb85af80686d0b71fb10d99b72901b63eba4e"></a>MUX_0V0&#160;</td><td class="fielddoc"><p >GND.</p>
<p >GND. ADC8 analogue input. </p>
</td></tr>
</table>

</div>
</div>
<a id="a5f9313bcb77c86750f8ec1ed1a9f0c6e" name="a5f9313bcb77c86750f8ec1ed1a9f0c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9313bcb77c86750f8ec1ed1a9f0c6e">&#9670;&nbsp;</a></span>_mux1_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_scan_a_d_c.html#a5f9313bcb77c86750f8ec1ed1a9f0c6e">ScanADC::_mux1_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATmega1280/ATmega2560 Hardware analogue input MUX value. </p>
<p >Only available if <b>AVR_ATmega1280</b> or <b>AVR_ATmega2560</b> are defined by Arduino environment. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af9924ab9820692b7635c8cd1347a8240" name="a2f390b2dceb4266b842ea7fea619bb85af9924ab9820692b7635c8cd1347a8240"></a>MUX_ADC0&#160;</td><td class="fielddoc"><p >ADC0 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85ab217c7a2f9803059c1446200f65677b6" name="a2f390b2dceb4266b842ea7fea619bb85ab217c7a2f9803059c1446200f65677b6"></a>MUX_ADC1&#160;</td><td class="fielddoc"><p >ADC1 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f9313bcb77c86750f8ec1ed1a9f0c6ea740d5fbc6f3d4372e57b64031e71ebe4" name="a5f9313bcb77c86750f8ec1ed1a9f0c6ea740d5fbc6f3d4372e57b64031e71ebe4"></a>MUX_ADC2&#160;</td><td class="fielddoc"><p >ADC2 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f9313bcb77c86750f8ec1ed1a9f0c6ead0145f78e5813c6f87407aada95a101b" name="a5f9313bcb77c86750f8ec1ed1a9f0c6ead0145f78e5813c6f87407aada95a101b"></a>MUX_ADC3&#160;</td><td class="fielddoc"><p >ADC3 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af5dd6deb531b1f19d098d247423a60ec" name="a2f390b2dceb4266b842ea7fea619bb85af5dd6deb531b1f19d098d247423a60ec"></a>MUX_ADC4&#160;</td><td class="fielddoc"><p >ADC4 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af36f98f268be110012e83f57ac326e92" name="a2f390b2dceb4266b842ea7fea619bb85af36f98f268be110012e83f57ac326e92"></a>MUX_ADC5&#160;</td><td class="fielddoc"><p >ADC5 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a5b6e20d2bef84685367567574987320b" name="a2f390b2dceb4266b842ea7fea619bb85a5b6e20d2bef84685367567574987320b"></a>MUX_ADC6&#160;</td><td class="fielddoc"><p >ADC6 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a306b7cca5e7b3d0b769e2f7faf088ddc" name="a2f390b2dceb4266b842ea7fea619bb85a306b7cca5e7b3d0b769e2f7faf088ddc"></a>MUX_ADC7&#160;</td><td class="fielddoc"><p >ADC7 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a7620e7e5d36370bb89d8069684851f14" name="a2f390b2dceb4266b842ea7fea619bb85a7620e7e5d36370bb89d8069684851f14"></a>MUX_1V1&#160;</td><td class="fielddoc"><p >1.1V internal bandgap. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af80686d0b71fb10d99b72901b63eba4e" name="a2f390b2dceb4266b842ea7fea619bb85af80686d0b71fb10d99b72901b63eba4e"></a>MUX_0V0&#160;</td><td class="fielddoc"><p >GND.</p>
<p >GND. ADC8 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85aa61638b19324c013c781766ef5d83c38" name="a2f390b2dceb4266b842ea7fea619bb85aa61638b19324c013c781766ef5d83c38"></a>MUX_ADC9&#160;</td><td class="fielddoc"><p >ADC9 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85ade2ab1ee248745ce36122d909b703c86" name="a2f390b2dceb4266b842ea7fea619bb85ade2ab1ee248745ce36122d909b703c86"></a>MUX_ADC10&#160;</td><td class="fielddoc"><p >ADC10 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a76684e1743f05c58c207c6b1ed585a66" name="a2f390b2dceb4266b842ea7fea619bb85a76684e1743f05c58c207c6b1ed585a66"></a>MUX_ADC11&#160;</td><td class="fielddoc"><p >ADC11 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a7ad182c23da9d8017848125333866bc7" name="a2f390b2dceb4266b842ea7fea619bb85a7ad182c23da9d8017848125333866bc7"></a>MUX_ADC12&#160;</td><td class="fielddoc"><p >ADC12 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a9a3fd0b936eacdfc74b3b307728a2c48" name="a2f390b2dceb4266b842ea7fea619bb85a9a3fd0b936eacdfc74b3b307728a2c48"></a>MUX_ADC13&#160;</td><td class="fielddoc"><p >ADC13 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f9313bcb77c86750f8ec1ed1a9f0c6ea87fd99c685ac02b18cd1f6da87cba443" name="a5f9313bcb77c86750f8ec1ed1a9f0c6ea87fd99c685ac02b18cd1f6da87cba443"></a>MUX_ADC14&#160;</td><td class="fielddoc"><p >ADC14 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f9313bcb77c86750f8ec1ed1a9f0c6ea9ff6f6709ca07893ce2b824e0122b9cd" name="a5f9313bcb77c86750f8ec1ed1a9f0c6ea9ff6f6709ca07893ce2b824e0122b9cd"></a>MUX_ADC15&#160;</td><td class="fielddoc"><p >ADC15 analogue input. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2f390b2dceb4266b842ea7fea619bb85" name="a2f390b2dceb4266b842ea7fea619bb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f390b2dceb4266b842ea7fea619bb85">&#9670;&nbsp;</a></span>_mux2_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_scan_a_d_c.html#a2f390b2dceb4266b842ea7fea619bb85">ScanADC::_mux2_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ATmega32U4/ATmega16U4 Hardware analogue input MUX value. </p>
<p >Only available if <b>AVR_ATmega32U4</b> or <b>AVR_ATmega16U4</b> are defined by Arduino environment. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af9924ab9820692b7635c8cd1347a8240" name="a2f390b2dceb4266b842ea7fea619bb85af9924ab9820692b7635c8cd1347a8240"></a>MUX_ADC0&#160;</td><td class="fielddoc"><p >ADC0 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85ab217c7a2f9803059c1446200f65677b6" name="a2f390b2dceb4266b842ea7fea619bb85ab217c7a2f9803059c1446200f65677b6"></a>MUX_ADC1&#160;</td><td class="fielddoc"><p >ADC1 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af5dd6deb531b1f19d098d247423a60ec" name="a2f390b2dceb4266b842ea7fea619bb85af5dd6deb531b1f19d098d247423a60ec"></a>MUX_ADC4&#160;</td><td class="fielddoc"><p >ADC4 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af36f98f268be110012e83f57ac326e92" name="a2f390b2dceb4266b842ea7fea619bb85af36f98f268be110012e83f57ac326e92"></a>MUX_ADC5&#160;</td><td class="fielddoc"><p >ADC5 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a5b6e20d2bef84685367567574987320b" name="a2f390b2dceb4266b842ea7fea619bb85a5b6e20d2bef84685367567574987320b"></a>MUX_ADC6&#160;</td><td class="fielddoc"><p >ADC6 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a306b7cca5e7b3d0b769e2f7faf088ddc" name="a2f390b2dceb4266b842ea7fea619bb85a306b7cca5e7b3d0b769e2f7faf088ddc"></a>MUX_ADC7&#160;</td><td class="fielddoc"><p >ADC7 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a7620e7e5d36370bb89d8069684851f14" name="a2f390b2dceb4266b842ea7fea619bb85a7620e7e5d36370bb89d8069684851f14"></a>MUX_1V1&#160;</td><td class="fielddoc"><p >1.1V internal bandgap. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85af80686d0b71fb10d99b72901b63eba4e" name="a2f390b2dceb4266b842ea7fea619bb85af80686d0b71fb10d99b72901b63eba4e"></a>MUX_0V0&#160;</td><td class="fielddoc"><p >GND.</p>
<p >GND. ADC8 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85aa0957c67d95c54942133171a6385e9d2" name="a2f390b2dceb4266b842ea7fea619bb85aa0957c67d95c54942133171a6385e9d2"></a>MUX_ADC8&#160;</td><td class="fielddoc"><p >ADC8 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85aa61638b19324c013c781766ef5d83c38" name="a2f390b2dceb4266b842ea7fea619bb85aa61638b19324c013c781766ef5d83c38"></a>MUX_ADC9&#160;</td><td class="fielddoc"><p >ADC9 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85ade2ab1ee248745ce36122d909b703c86" name="a2f390b2dceb4266b842ea7fea619bb85ade2ab1ee248745ce36122d909b703c86"></a>MUX_ADC10&#160;</td><td class="fielddoc"><p >ADC10 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a76684e1743f05c58c207c6b1ed585a66" name="a2f390b2dceb4266b842ea7fea619bb85a76684e1743f05c58c207c6b1ed585a66"></a>MUX_ADC11&#160;</td><td class="fielddoc"><p >ADC11 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a7ad182c23da9d8017848125333866bc7" name="a2f390b2dceb4266b842ea7fea619bb85a7ad182c23da9d8017848125333866bc7"></a>MUX_ADC12&#160;</td><td class="fielddoc"><p >ADC12 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85a9a3fd0b936eacdfc74b3b307728a2c48" name="a2f390b2dceb4266b842ea7fea619bb85a9a3fd0b936eacdfc74b3b307728a2c48"></a>MUX_ADC13&#160;</td><td class="fielddoc"><p >ADC13 analogue input. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2f390b2dceb4266b842ea7fea619bb85afe678f683c300c4e727d667d021ccf1d" name="a2f390b2dceb4266b842ea7fea619bb85afe678f683c300c4e727d667d021ccf1d"></a>MUX_TEMP&#160;</td><td class="fielddoc"><p >Temperature sensor. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf871108bd5f9f119d4204eba59ea5b3" name="aaf871108bd5f9f119d4204eba59ea5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf871108bd5f9f119d4204eba59ea5b3">&#9670;&nbsp;</a></span>attach_channel_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScanADC::attach_channel_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_scan_a_d_c.html#a42496a3bdb8d9fdbc8e859da1294e5e5">channel_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures callback function to be called after each analogue channel is scanned. </p>
<p >The channel callback, if enables, is called after a channel has been measured an will supply the <em>channel</em> and the <em>sample</em> as parameters.</p>
<p >The callback is enabled when a user defined function pointer <em>cb</em> is supplied and disabled when NULL is passed as the function pointer.</p>
<p >Note that this function is safe to call while scanning is in operation.</p>
<p >Note that the callback is called from the ADC Interrupt Service Routine (ISR) and should be as short as possible. An example use is to push the sample into a queue for processing by the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Pointer to callback function or NULL to disable callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11b84626f2f8d6dc7a9c290e630bfe3d" name="a11b84626f2f8d6dc7a9c290e630bfe3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b84626f2f8d6dc7a9c290e630bfe3d">&#9670;&nbsp;</a></span>attach_scan_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScanADC::attach_scan_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_scan_a_d_c.html#a55d2f660be94c65031f4f713f3283803">channel_scan_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures callback function to be called after all analogue channels are scanned. </p>
<p >The channel scan callback, if enables, is called after all the channels in the configuration have been measured and will supply a pointer to the channel samples #samples.</p>
<p >The callback is enabled when a user defined function pointer is supplied and disabled when NULL is passed as the function pointer.</p>
<p >Note that this function is safe to call while scanning is in operation.</p>
<p >Note that the callback is called from the ADC Interrupt Service Routine (ISR) and should be as short as possible. An example use is to push the samples into a queue for processing by the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Pointer to callback function or NULL to disable callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32a830c35b1e665023fd9145e43c12b6" name="a32a830c35b1e665023fd9145e43c12b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a830c35b1e665023fd9145e43c12b6">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScanADC::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_scan_a_d_c_1_1channel__config__t.html">channel_config_t</a> *&#160;</td>
          <td class="paramname"><em>channel_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts scanning user defined analogue input channnels with the ADC under interrupt control. </p>
<p >This function takes in the configuration of the channels to scan as a pointer to the configuration array <em>channel_config</em> and channel count <em>channel_count</em> and starts the scanning. A copy is made internally of the configuration. The ADC hardware is configured and ADC interrupt enabled for background ADC control, measurement and optional averaging of configured channels in round-robin fashion. The measurement always starts at channel 0 and wraps back after channel <em>channel</em> - 1.</p>
<p >To stop the scanning call <a class="el" href="class_scan_a_d_c.html#a84b25eaea32c0626af37713c9160edd3" title="Stops scanning disabling interrupt control.">end()</a>.</p>
<p >Example from 4-axis RC controller example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define LEFT_STICK_X_ADC           ScanADC::MUX_ADC7   </span><span class="comment">// A0</span></div>
<div class="line"><span class="preprocessor">#define LEFT_STICK_Y_ADC           ScanADC::MUX_ADC6   </span><span class="comment">// A1</span></div>
<div class="line"><span class="preprocessor">#define RIGHT_STICK_X_ADC          ScanADC::MUX_ADC5   </span><span class="comment">// A2</span></div>
<div class="line"><span class="preprocessor">#define RIGHT_STICK_Y_ADC          ScanADC::MUX_ADC4   </span><span class="comment">// A3</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="struct_scan_a_d_c_1_1channel__config__t.html">ScanADC::channel_config_t</a> config[] =</div>
<div class="line">{</div>
<div class="line">    { LEFT_STICK_X_ADC, 8 },   <span class="comment">// YAW</span></div>
<div class="line">    { LEFT_STICK_Y_ADC, 8 },   <span class="comment">// THROTTLE</span></div>
<div class="line">    { RIGHT_STICK_X_ADC, 8 },  <span class="comment">// ROLL</span></div>
<div class="line">    { RIGHT_STICK_Y_ADC, 8 },  <span class="comment">// PITCH</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">adc_scanner.begin(config, 4);</div>
<div class="ttc" id="astruct_scan_a_d_c_1_1channel__config__t_html"><div class="ttname"><a href="struct_scan_a_d_c_1_1channel__config__t.html">ScanADC::channel_config_t</a></div><div class="ttdoc">Structure to hold configuration for a single channel.</div><div class="ttdef"><b>Definition:</b> ScanADC.h:161</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_config</td><td>Pointer to array with channel configurations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_count</td><td>Channel count to configure. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_scan_a_d_c_a32a830c35b1e665023fd9145e43c12b6_cgraph.png" border="0" usemap="#aclass_scan_a_d_c_a32a830c35b1e665023fd9145e43c12b6_cgraph" alt=""/></div>
<map name="aclass_scan_a_d_c_a32a830c35b1e665023fd9145e43c12b6_cgraph" id="aclass_scan_a_d_c_a32a830c35b1e665023fd9145e43c12b6_cgraph">
<area shape="rect" title="Starts scanning user defined analogue input channnels with the ADC under interrupt control." alt="" coords="5,5,121,32"/>
<area shape="rect" href="class_scan_a_d_c.html#a84b25eaea32c0626af37713c9160edd3" title="Stops scanning disabling interrupt control." alt="" coords="169,5,276,32"/>
</map>
</div>

</div>
</div>
<a id="a84b25eaea32c0626af37713c9160edd3" name="a84b25eaea32c0626af37713c9160edd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b25eaea32c0626af37713c9160edd3">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScanADC::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops scanning disabling interrupt control. </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_scan_a_d_c_a84b25eaea32c0626af37713c9160edd3_icgraph.png" border="0" usemap="#aclass_scan_a_d_c_a84b25eaea32c0626af37713c9160edd3_icgraph" alt=""/></div>
<map name="aclass_scan_a_d_c_a84b25eaea32c0626af37713c9160edd3_icgraph" id="aclass_scan_a_d_c_a84b25eaea32c0626af37713c9160edd3_icgraph">
<area shape="rect" title="Stops scanning disabling interrupt control." alt="" coords="169,5,276,32"/>
<area shape="rect" href="class_scan_a_d_c.html#a32a830c35b1e665023fd9145e43c12b6" title="Starts scanning user defined analogue input channnels with the ADC under interrupt control." alt="" coords="5,5,121,32"/>
</map>
</div>

</div>
</div>
<a id="ae11e9b305b91547986150c1fbf5a08fa" name="ae11e9b305b91547986150c1fbf5a08fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11e9b305b91547986150c1fbf5a08fa">&#9670;&nbsp;</a></span>get_sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ScanADC::get_sample </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads sample for a user configure channel. </p>
<p >This returns the last measured 10-bit sample for a channel.</p>
<p >Note this function is always safe to call even without client synchronisation via <a class="el" href="class_scan_a_d_c.html#a31c313a5cc6692c6761150ba2aa7b72e" title="Waits until a specified user configured channel has been measured.">wait_channel()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>Channel index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint16_t 10-bit unsigned sample. </dd></dl>

</div>
</div>
<a id="a68c8517ad8aca9dcffd5e2b0e34f8076" name="a68c8517ad8aca9dcffd5e2b0e34f8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c8517ad8aca9dcffd5e2b0e34f8076">&#9670;&nbsp;</a></span>get_sn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ScanADC::get_sn </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the sample sequence number for a channel. </p>
<p >Each channel has an individual cycling sequence number counter from 0 to 255 that is incremented once a measurement is completed and available for the channel. For a scan all the indexes will be the same for all channels once all the channels in the scan have beem measured. The sequence numbers for all channels are zeroed by <a class="el" href="class_scan_a_d_c.html#a32a830c35b1e665023fd9145e43c12b6" title="Starts scanning user defined analogue input channnels with the ADC under interrupt control.">begin()</a>.</p>
<p >Note this function is always safe to call even without client synchronisation via <a class="el" href="class_scan_a_d_c.html#a31c313a5cc6692c6761150ba2aa7b72e" title="Waits until a specified user configured channel has been measured.">wait_channel()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>Channel index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Sequence number cycling from zero to 255. </dd></dl>

</div>
</div>
<a id="a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30" name="a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30">&#9670;&nbsp;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_scan_a_d_c.html">ScanADC</a> &amp; ScanADC::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the single object of <a class="el" href="class_scan_a_d_c.html" title="Class to scan analogue inputs with ADC measuring and averaging in background under interrupt control.">ScanADC</a>. </p>
<p >This implement the singleton pattern to ensure only one single object of this class exists. In princible sharing the ADC and Interrupt Service Routine by multiple object could have been engineered but it would add considerable complexity for little gain.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_scan_a_d_c.html" title="Class to scan analogue inputs with ADC measuring and averaging in background under interrupt control.">ScanADC</a>&amp; Instance of <a class="el" href="class_scan_a_d_c.html" title="Class to scan analogue inputs with ADC measuring and averaging in background under interrupt control.">ScanADC</a>. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_scan_a_d_c_a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30_icgraph.png" border="0" usemap="#aclass_scan_a_d_c_a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30_icgraph" alt=""/></div>
<map name="aclass_scan_a_d_c_a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30_icgraph" id="aclass_scan_a_d_c_a79b87f5f9ff3c1dfc7a6eb4ddf5fcb30_icgraph">
<area shape="rect" title="Get the single object of ScanADC." alt="" coords="97,5,251,32"/>
<area shape="rect" href="_scan_a_d_c_8cpp.html#a05c2e5b588ced1cd7312f5b0edc5b295" title=" " alt="" coords="5,5,49,32"/>
</map>
</div>

</div>
</div>
<a id="a31c313a5cc6692c6761150ba2aa7b72e" name="a31c313a5cc6692c6761150ba2aa7b72e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c313a5cc6692c6761150ba2aa7b72e">&#9670;&nbsp;</a></span>wait_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScanADC::wait_channel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until a specified user configured channel has been measured. </p>
<p >This function will wait for the sample measurement to finish for <em>channel</em> and is useful for synchronising the client with the background measurement. It works by detecting a change in a per channel sequence number that is incremented after a channel measurement.</p>
<p >Since channels are scanned and measured in round-bin fashion from 0 to the configured channel count, waiting for a channel is often enough to synchronize to multiple channels in a scan. For instance, waiting for the channel count minus 1 can be used to synchronise to all channels being measured provided the sample from 0 can be read by <a class="el" href="class_scan_a_d_c.html#ae11e9b305b91547986150c1fbf5a08fa" title="Reads sample for a user configure channel.">get_sample()</a> before it is overwritten by the next scan of measurements. The time available for reading channel 0 is dependent on the ADC clock rate and the number of samples being averaged. Since a sample is measured every 12us, this time is approximately 12us times (2 to the power of <em>sample_count_log2</em>).</p>
<p >If this function is used to wait for continuous samples, it must always be running before <em>channel</em> measurement completes otherwise samples will be skipped.</p>
<p >Example from 4-axis RC controller example: </p><div class="fragment"><div class="line">adc_scanner.wait_channel(3);</div>
<div class="line"> </div>
<div class="line">sn = adc_scanner.get_sn(3);</div>
<div class="line">left_x = adc_scanner.get_sample(0);</div>
<div class="line">left_y = adc_scanner.get_sample(1);</div>
<div class="line">right_x = adc_scanner.get_sample(2);</div>
<div class="line">right_y = adc_scanner.get_sample(3);</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>Channel index. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_scan_a_d_c_a31c313a5cc6692c6761150ba2aa7b72e_icgraph.png" border="0" usemap="#aclass_scan_a_d_c_a31c313a5cc6692c6761150ba2aa7b72e_icgraph" alt=""/></div>
<map name="aclass_scan_a_d_c_a31c313a5cc6692c6761150ba2aa7b72e_icgraph" id="aclass_scan_a_d_c_a31c313a5cc6692c6761150ba2aa7b72e_icgraph">
<area shape="rect" title="Waits until a specified user configured channel has been measured." alt="" coords="197,5,359,32"/>
<area shape="rect" href="class_scan_a_d_c.html#aa742f25553a586182136cbb4a2387faf" title="Waits until all the user configured channels have been measured." alt="" coords="5,5,149,32"/>
</map>
</div>

</div>
</div>
<a id="aa742f25553a586182136cbb4a2387faf" name="aa742f25553a586182136cbb4a2387faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa742f25553a586182136cbb4a2387faf">&#9670;&nbsp;</a></span>wait_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ScanADC::wait_scan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until all the user configured channels have been measured. </p>
<p >This is equvalent to wait_channel(<em>channel_count</em> - 1). </p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_scan_a_d_c_aa742f25553a586182136cbb4a2387faf_cgraph.png" border="0" usemap="#aclass_scan_a_d_c_aa742f25553a586182136cbb4a2387faf_cgraph" alt=""/></div>
<map name="aclass_scan_a_d_c_aa742f25553a586182136cbb4a2387faf_cgraph" id="aclass_scan_a_d_c_aa742f25553a586182136cbb4a2387faf_cgraph">
<area shape="rect" title="Waits until all the user configured channels have been measured." alt="" coords="5,5,149,32"/>
<area shape="rect" href="class_scan_a_d_c.html#a31c313a5cc6692c6761150ba2aa7b72e" title="Waits until a specified user configured channel has been measured." alt="" coords="197,5,359,32"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0d87c3127939beead634c98f160e7b38" name="a0d87c3127939beead634c98f160e7b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d87c3127939beead634c98f160e7b38">&#9670;&nbsp;</a></span>__vector_29</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void __vector_29 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ADC Interrupt Service Routine (ISR) declared as friend to allow access to member variables. </p>
<p >ADC Interrupt Service Routine (ISR) has C linkage. Declaration used to create a friend of the class to access member variables. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_scan_a_d_c_8h_source.html">ScanADC.h</a></li>
<li>src/<a class="el" href="_scan_a_d_c_8cpp.html">ScanADC.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
